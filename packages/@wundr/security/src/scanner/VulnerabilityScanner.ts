import * as fs from 'fs/promises';
import * as path from 'path';
import * as semver from 'semver';
import { EventEmitter } from 'events';
import axios from 'axios';
import { logger } from '../utils/logger';

export interface Package {
  name: string;
  version: string;
  path: string;
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
}

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'low' | 'moderate' | 'high' | 'critical';
  cvssScore?: number;
  cwe?: string[];
  references: string[];
  vulnerableVersions: string;
  patchedVersions?: string;
  overview: string;
  recommendation: string;
  publishedAt: string;
  updatedAt: string;
}

export interface VulnerabilityMatch {
  package: Package;
  vulnerability: Vulnerability;
  installedVersion: string;
  fixedVersion?: string;
  path: string[];
}

export interface ScanResult {
  vulnerabilities: VulnerabilityMatch[];
  packages: Package[];
  summary: {
    critical: number;
    high: number;
    moderate: number;
    low: number;
    total: number;
  };
  scanDuration: number;
  lastUpdated: string;
}

export interface DatabaseOptions {
  updateInterval?: number; // in milliseconds
  customSources?: string[];
  offline?: boolean;
}

export class VulnerabilityScanner extends EventEmitter {
  private vulnerabilityDatabase: Map<string, Vulnerability[]> = new Map();
  private lastDatabaseUpdate: Date | null = null;
  private updateInterval: number;
  private customSources: string[];
  private offline: boolean;

  private static readonly DEFAULT_SOURCES = [
    'https://registry.npmjs.org/-/npm/v1/security/advisories',
    'https://api.github.com/advisories',
    'https://nvd.nist.gov/feeds/json/cve/1.1'
  ];

  constructor(options: DatabaseOptions = {}) {
    super();
    this.updateInterval = options.updateInterval || 24 * 60 * 60 * 1000; // 24 hours
    this.customSources = options.customSources || VulnerabilityScanner.DEFAULT_SOURCES;
    this.offline = options.offline || false;
    
    this.setupUpdateSchedule();
  }

  /**
   * Scan project for vulnerabilities
   */
  async scanProject(projectPath: string): Promise<ScanResult> {
    const startTime = Date.now();
    
    try {
      this.emit('scan:started', { projectPath });

      // Update vulnerability database if needed
      if (!this.offline) {
        await this.updateVulnerabilityDatabase();
      }

      // Discover packages
      const packages = await this.discoverPackages(projectPath);
      this.emit('scan:packages-discovered', { count: packages.length });

      // Check vulnerabilities
      const vulnerabilities = await this.checkVulnerabilities(packages);
      
      const scanDuration = Date.now() - startTime;
      const result: ScanResult = {
        vulnerabilities,
        packages,
        summary: this.createSummary(vulnerabilities),
        scanDuration,
        lastUpdated: this.lastDatabaseUpdate?.toISOString() || new Date().toISOString()
      };

      this.emit('scan:completed', result);
      return result;

    } catch (error) {
      logger.error('Vulnerability scan failed:', error);
      throw error;
    }
  }

  /**
   * Scan specific package for vulnerabilities
   */
  async scanPackage(packageName: string, version: string): Promise<VulnerabilityMatch[]> {
    const vulnerabilities = this.vulnerabilityDatabase.get(packageName) || [];
    const matches: VulnerabilityMatch[] = [];

    for (const vuln of vulnerabilities) {
      if (this.isVersionVulnerable(version, vuln.vulnerableVersions)) {
        const fixedVersion = this.getFixedVersion(vuln.patchedVersions, version);
        
        matches.push({
          package: {
            name: packageName,
            version,
            path: ''
          },
          vulnerability: vuln,
          installedVersion: version,
          fixedVersion,
          path: [packageName]
        });
      }
    }

    return matches;
  }

  /**
   * Update vulnerability database from sources
   */
  async updateVulnerabilityDatabase(): Promise<void> {
    if (this.offline) {
      return;
    }

    const now = new Date();
    if (this.lastDatabaseUpdate && 
        (now.getTime() - this.lastDatabaseUpdate.getTime()) < this.updateInterval) {
      return; // Still fresh
    }

    try {
      this.emit('database:updating');
      
      // Load from multiple sources
      const promises = this.customSources.map(source => this.loadVulnerabilitiesFromSource(source));
      const results = await Promise.allSettled(promises);
      
      let totalLoaded = 0;
      for (const result of results) {
        if (result.status === 'fulfilled') {
          totalLoaded += result.value;
        } else {
          logger.warn('Failed to load from source:', result.reason);
        }
      }

      this.lastDatabaseUpdate = now;
      this.emit('database:updated', { totalVulnerabilities: totalLoaded });

    } catch (error) {
      logger.error('Failed to update vulnerability database:', error);
      throw error;
    }
  }

  /**
   * Generate security report
   */
  generateReport(scanResult: ScanResult): string {
    const report = [];
    
    report.push('# Security Vulnerability Report');
    report.push(`Generated: ${new Date().toISOString()}`);
    report.push(`Scan Duration: ${scanResult.scanDuration}ms`);
    report.push('');

    // Summary
    report.push('## Summary');
    report.push(`- Total Vulnerabilities: ${scanResult.summary.total}`);
    report.push(`- Critical: ${scanResult.summary.critical}`);
    report.push(`- High: ${scanResult.summary.high}`);
    report.push(`- Moderate: ${scanResult.summary.moderate}`);
    report.push(`- Low: ${scanResult.summary.low}`);
    report.push('');

    // Critical vulnerabilities first
    const criticalVulns = scanResult.vulnerabilities.filter(v => v.vulnerability.severity === 'critical');
    if (criticalVulns.length > 0) {
      report.push('## Critical Vulnerabilities');
      criticalVulns.forEach(vuln => {
        report.push(`### ${vuln.vulnerability.title}`);
        report.push(`Package: ${vuln.package.name}@${vuln.installedVersion}`);
        report.push(`Vulnerability ID: ${vuln.vulnerability.id}`);
        report.push(`Description: ${vuln.vulnerability.description}`);
        if (vuln.fixedVersion) {
          report.push(`Fix: Upgrade to ${vuln.fixedVersion}`);
        }
        report.push(`Recommendation: ${vuln.vulnerability.recommendation}`);
        report.push('');
      });
    }

    // High vulnerabilities
    const highVulns = scanResult.vulnerabilities.filter(v => v.vulnerability.severity === 'high');
    if (highVulns.length > 0) {
      report.push('## High Severity Vulnerabilities');
      highVulns.forEach(vuln => {
        report.push(`- ${vuln.vulnerability.title} in ${vuln.package.name}@${vuln.installedVersion}`);
        if (vuln.fixedVersion) {
          report.push(`  Fix: Upgrade to ${vuln.fixedVersion}`);
        }
      });
      report.push('');
    }

    // Recommendations
    report.push('## Recommendations');
    report.push('1. Update all packages to their latest secure versions');
    report.push('2. Run vulnerability scans regularly as part of CI/CD');
    report.push('3. Monitor security advisories for used packages');
    report.push('4. Consider using automated dependency updates');
    
    return report.join('\n');
  }

  /**
   * Get fix suggestions for vulnerabilities
   */
  getFixSuggestions(vulnerabilities: VulnerabilityMatch[]): Array<{
    package: string;
    currentVersion: string;
    suggestedVersion: string;
    command: string;
    priority: 'high' | 'medium' | 'low';
  }> {
    const suggestions: Array<{
      package: string;
      currentVersion: string;
      suggestedVersion: string;
      command: string;
      priority: 'high' | 'medium' | 'low';
    }> = [];
    
    for (const vuln of vulnerabilities) {
      if (vuln.fixedVersion) {
        const priority: 'high' | 'medium' | 'low' = vuln.vulnerability.severity === 'critical' || vuln.vulnerability.severity === 'high' 
          ? 'high' : vuln.vulnerability.severity === 'moderate' ? 'medium' : 'low';
          
        suggestions.push({
          package: vuln.package.name,
          currentVersion: vuln.installedVersion,
          suggestedVersion: vuln.fixedVersion,
          command: `npm install ${vuln.package.name}@${vuln.fixedVersion}`,
          priority
        });
      }
    }

    // Sort by priority and deduplicate
    return suggestions
      .sort((a, b) => {
        const priorityOrder: Record<'high' | 'medium' | 'low', number> = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
      })
      .filter((suggestion, index, array) => 
        index === array.findIndex(s => s.package === suggestion.package)
      );
  }

  private async discoverPackages(projectPath: string): Promise<Package[]> {
    const packages: Package[] = [];
    
    // Find all package.json files
    const packageFiles = await this.findPackageFiles(projectPath);
    
    for (const packageFile of packageFiles) {
      try {
        const content = await fs.readFile(packageFile, 'utf-8');
        const packageJson = JSON.parse(content);
        
        const pkg: Package = {
          name: packageJson.name || 'unknown',
          version: packageJson.version || '0.0.0',
          path: packageFile,
          dependencies: packageJson.dependencies,
          devDependencies: packageJson.devDependencies
        };
        
        packages.push(pkg);
        
        // Also add dependencies as packages to check
        if (packageJson.dependencies) {
          for (const [name, version] of Object.entries(packageJson.dependencies)) {
            packages.push({
              name,
              version: version as string,
              path: packageFile
            });
          }
        }
        
      } catch (error) {
        logger.warn(`Failed to parse ${packageFile}:`, error);
      }
    }
    
    return packages;
  }

  private async findPackageFiles(dir: string, files: string[] = []): Promise<string[]> {
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.name === 'node_modules' || entry.name === '.git') {
          continue; // Skip common directories that shouldn't contain our package files
        }
        
        if (entry.isDirectory()) {
          await this.findPackageFiles(fullPath, files);
        } else if (entry.name === 'package.json') {
          files.push(fullPath);
        }
      }
      
      return files;
    } catch (error) {
      logger.warn(`Failed to read directory ${dir}:`, error);
      return files;
    }
  }

  private async checkVulnerabilities(packages: Package[]): Promise<VulnerabilityMatch[]> {
    const vulnerabilities: VulnerabilityMatch[] = [];
    
    for (const pkg of packages) {
      const packageVulns = await this.scanPackage(pkg.name, pkg.version);
      vulnerabilities.push(...packageVulns);
    }
    
    return vulnerabilities;
  }

  private async loadVulnerabilitiesFromSource(source: string): Promise<number> {
    try {
      if (source.includes('npmjs.org')) {
        return await this.loadNpmAdvisories(source);
      } else if (source.includes('github.com')) {
        return await this.loadGitHubAdvisories(source);
      } else {
        return await this.loadGenericAdvisories(source);
      }
    } catch (error) {
      logger.warn(`Failed to load vulnerabilities from ${source}:`, error);
      return 0;
    }
  }

  private async loadNpmAdvisories(source: string): Promise<number> {
    // Mock implementation - in reality, you'd load from NPM advisory database
    const mockData = {
      'lodash': [{
        id: 'GHSA-35jh-r3h4-6jhm',
        title: 'Prototype Pollution in lodash',
        description: 'Versions of lodash before 4.17.12 are vulnerable to Prototype Pollution.',
        severity: 'low' as const,
        vulnerableVersions: '<4.17.12',
        patchedVersions: '>=4.17.12',
        overview: 'The vulnerability is fixed in version 4.17.12',
        recommendation: 'Upgrade to lodash 4.17.12 or higher',
        references: ['https://github.com/advisories/GHSA-35jh-r3h4-6jhm'],
        publishedAt: '2020-05-01T00:00:00Z',
        updatedAt: '2020-05-01T00:00:00Z'
      }],
      'axios': [{
        id: 'GHSA-42xw-2xvc-qx8m',
        title: 'Server-Side Request Forgery in axios',
        description: 'Axios NPM package 0.21.0 contains a Server-Side Request Forgery (SSRF) vulnerability.',
        severity: 'moderate' as const,
        vulnerableVersions: '=0.21.0',
        patchedVersions: '>=0.21.1',
        overview: 'The vulnerability is fixed in version 0.21.1',
        recommendation: 'Upgrade to axios 0.21.1 or higher',
        references: ['https://github.com/advisories/GHSA-42xw-2xvc-qx8m'],
        publishedAt: '2020-12-01T00:00:00Z',
        updatedAt: '2020-12-01T00:00:00Z'
      }]
    };

    let count = 0;
    for (const [packageName, vulnerabilities] of Object.entries(mockData)) {
      this.vulnerabilityDatabase.set(packageName, vulnerabilities);
      count += vulnerabilities.length;
    }

    return count;
  }

  private async loadGitHubAdvisories(source: string): Promise<number> {
    // Mock GitHub Security Advisories
    return 0;
  }

  private async loadGenericAdvisories(source: string): Promise<number> {
    // Mock generic advisory loading
    return 0;
  }

  private isVersionVulnerable(version: string, vulnerableVersions: string): boolean {
    try {
      return semver.satisfies(version, vulnerableVersions);
    } catch (error) {
      logger.warn(`Invalid version or range: ${version}, ${vulnerableVersions}`);
      return false;
    }
  }

  private getFixedVersion(patchedVersions: string | undefined, currentVersion: string): string | undefined {
    if (!patchedVersions) return undefined;
    
    try {
      // Find the lowest version that satisfies the patched versions range
      // This is a simplified implementation
      const range = patchedVersions.replace('>=', '');
      return semver.valid(range) ? range : undefined;
    } catch {
      return undefined;
    }
  }

  private createSummary(vulnerabilities: VulnerabilityMatch[]) {
    const summary = {
      critical: 0,
      high: 0,
      moderate: 0,
      low: 0,
      total: vulnerabilities.length
    };

    for (const vuln of vulnerabilities) {
      summary[vuln.vulnerability.severity]++;
    }

    return summary;
  }

  private setupUpdateSchedule(): void {
    if (this.offline) return;
    
    setInterval(async () => {
      try {
        await this.updateVulnerabilityDatabase();
      } catch (error) {
        logger.error('Scheduled vulnerability database update failed:', error);
      }
    }, this.updateInterval);
  }
}