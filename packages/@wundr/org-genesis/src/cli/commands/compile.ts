/* eslint-disable no-console */
/**
 * @packageDocumentation
 * Compile Command - Compiles session context for a Orchestrator and discipline.
 *
 * This command uses the Context Compiler to generate a complete session
 * configuration including CLAUDE.md, claude_config.json, settings.json,
 * and agent definitions. The compiled configuration can be written to
 * a git worktree for immediate use.
 *
 * @module cli/commands/compile
 */

import { createRegistryManager } from '../../registry/index.js';

import type {
  CompiledSessionConfig,
  SessionContext,
} from '../../types/index.js';

// Note: ContextCompiler will be imported when fully implemented
// import { createContextCompiler, type CompileResult } from '../../context-compiler/index.js';

// =============================================================================
// TYPES & INTERFACES
// =============================================================================

/**
 * Options for the compile command.
 *
 * @example
 * ```typescript
 * const options: CompileOptions = {
 *   taskDescription: 'Implement user authentication',
 *   worktreePath: './worktrees/auth-feature',
 *   additionalAgents: ['security-reviewer'],
 *   writeFiles: true,
 * };
 * ```
 */
export interface CompileOptions {
  /**
   * Description of the task to be performed.
   * @required
   */
  taskDescription: string;

  /**
   * Path to the git worktree for file output.
   * If not provided, files are not written.
   */
  worktreePath?: string;

  /**
   * Additional agent IDs to include beyond discipline defaults.
   */
  additionalAgents?: string[];

  /**
   * Context from a previous session for warm-starting.
   */
  warmStartContext?: string;

  /**
   * MCP configuration overrides.
   */
  mcpOverrides?: Record<string, unknown>;

  /**
   * Whether to write compiled files to the worktree.
   * @default false
   */
  writeFiles?: boolean;

  /**
   * Base path for the repository (for worktree creation).
   */
  repoPath?: string;

  /**
   * Run in dry-run mode without writing files.
   * @default false
   */
  dryRun?: boolean;

  /**
   * Output format for the command result.
   * @default 'text'
   */
  outputFormat?: 'text' | 'json';

  /**
   * Path to the registry storage.
   * @default './.wundr/registry'
   */
  registryPath?: string;
}

/**
 * Result returned from the compile operation.
 */
export interface CompileCommandResult {
  /**
   * Whether the operation succeeded.
   */
  success: boolean;

  /**
   * The compiled session configuration.
   */
  sessionConfig?: CompiledSessionConfig;

  /**
   * The session context if created.
   */
  sessionContext?: SessionContext;

  /**
   * Path to the worktree where files were written.
   */
  worktreePath?: string;

  /**
   * List of files that were written.
   */
  filesWritten?: string[];

  /**
   * Compilation time in milliseconds.
   */
  compilationTimeMs?: number;

  /**
   * Error message if the operation failed.
   */
  error?: string;

  /**
   * Warnings encountered during compilation.
   */
  warnings: string[];
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/**
 * Generates a unique session ID.
 *
 * @returns Unique session ID
 */
function generateSessionId(): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 8);
  return `session-${timestamp}${random}`;
}

/**
 * Generates a CLAUDE.md content from discipline and task.
 *
 * @param disciplineName - Name of the discipline
 * @param role - The role from CLAUDE.md config
 * @param context - The context from CLAUDE.md config
 * @param rules - The rules from CLAUDE.md config
 * @param objectives - The objectives from CLAUDE.md config
 * @param constraints - The constraints from CLAUDE.md config
 * @param taskDescription - The task description
 * @returns Generated CLAUDE.md content
 */
function generateClaudeMdContent(
  disciplineName: string,
  role: string,
  context: string,
  rules: string[],
  objectives: string[],
  constraints: string[],
  taskDescription: string
): string {
  return `# ${disciplineName} Session Configuration

## Role
${role}

## Context
${context}

## Current Task
${taskDescription}

## Rules
${rules.map(r => `- ${r}`).join('\n')}

## Objectives
${objectives.map(o => `- ${o}`).join('\n')}

## Constraints
${constraints.map(c => `- ${c}`).join('\n')}

---
Generated by Wundr Org Genesis
`;
}

/**
 * Formats the result as text output.
 *
 * @param result - The compile result
 */
function formatTextOutput(result: CompileCommandResult): void {
  if (result.success && result.sessionConfig) {
    console.log('\n');
    console.log('='.repeat(60));
    console.log('  Session Compiled Successfully!');
    console.log('='.repeat(60));
    console.log('');
    console.log('  Compilation Details');
    console.log('  ' + '-'.repeat(40));
    console.log(`  Session ID:       ${result.sessionContext?.id ?? 'N/A'}`);
    console.log(`  Compilation Time: ${result.compilationTimeMs ?? 0}ms`);
    console.log('');

    if (result.worktreePath) {
      console.log('  Output');
      console.log('  ' + '-'.repeat(40));
      console.log(`  Worktree Path: ${result.worktreePath}`);
      console.log('');
    }

    if (result.filesWritten && result.filesWritten.length > 0) {
      console.log('  Files Written');
      console.log('  ' + '-'.repeat(40));
      result.filesWritten.forEach(file => {
        console.log(`  - ${file}`);
      });
      console.log('');
    }

    console.log('  Configuration Summary');
    console.log('  ' + '-'.repeat(40));
    console.log(
      `  CLAUDE.md:     ${result.sessionConfig.claudeMdContent.length} bytes`
    );
    console.log(
      `  Config JSON:   ${Object.keys(result.sessionConfig.claudeConfigJson).length} keys`
    );
    console.log(
      `  Settings JSON: ${Object.keys(result.sessionConfig.settingsJson).length} keys`
    );
    console.log(
      `  Agent Defs:    ${result.sessionConfig.agentDefinitions.length} agents`
    );
    console.log('');

    if (result.warnings.length > 0) {
      console.log('  Warnings');
      console.log('  ' + '-'.repeat(40));
      result.warnings.forEach(warning => {
        console.log(`  ! ${warning}`);
      });
      console.log('');
    }

    console.log('='.repeat(60));
    console.log('');
  } else {
    console.error('\n  Error compiling session:');
    console.error(`  ${result.error}`);
    console.error('');
  }
}

/**
 * Formats the result as JSON output.
 *
 * @param result - The compile result
 */
function formatJsonOutput(result: CompileCommandResult): void {
  const output = {
    ...result,
    sessionContext: result.sessionContext
      ? {
          ...result.sessionContext,
          startedAt: result.sessionContext.startedAt?.toISOString(),
          completedAt: result.sessionContext.completedAt?.toISOString(),
        }
      : undefined,
  };
  console.log(JSON.stringify(output, null, 2));
}

// =============================================================================
// MAIN COMMAND HANDLER
// =============================================================================

/**
 * Compiles a session configuration for a Orchestrator and discipline.
 *
 * Uses the Context Compiler to generate CLAUDE.md, configuration files,
 * and agent definitions. Optionally writes the compiled files to a git
 * worktree for immediate use.
 *
 * @param vpId - The Orchestrator ID for the session
 * @param disciplineId - The discipline ID for the session
 * @param options - Compilation options
 * @returns Promise resolving to the compilation result
 *
 * @example
 * ```typescript
 * // Basic compilation
 * const result = await compileCommand('orchestrator-engineering', 'disc-frontend', {
 *   taskDescription: 'Implement login page',
 * });
 *
 * // Compile and write to worktree
 * const result = await compileCommand('orchestrator-engineering', 'disc-backend', {
 *   taskDescription: 'Build REST API endpoints',
 *   worktreePath: './worktrees/api-feature',
 *   writeFiles: true,
 *   additionalAgents: ['api-designer', 'security-reviewer'],
 * });
 *
 * // Warm-start from previous session
 * const result = await compileCommand('orchestrator-engineering', 'disc-frontend', {
 *   taskDescription: 'Continue implementing dashboard',
 *   warmStartContext: previousSessionContext,
 * });
 * ```
 */
export async function compileCommand(
  vpId: string,
  disciplineId: string,
  options: CompileOptions
): Promise<CompileCommandResult> {
  const warnings: string[] = [];
  const startTime = Date.now();

  try {
    // Initialize registry manager
    const registryManager = createRegistryManager({
      storageType: 'file',
      basePath: options.registryPath ?? './.wundr/registry',
    });
    await registryManager.initialize();

    // Verify Orchestrator exists
    const orchestrator = await registryManager.charters.getVP(vpId);
    if (!vp) {
      return {
        success: false,
        error: `Orchestrator not found: ${vpId}`,
        warnings,
      };
    }

    // Verify discipline exists
    const discipline = await registryManager.disciplines.get(disciplineId);
    if (!discipline) {
      return {
        success: false,
        error: `Discipline not found: ${disciplineId}`,
        warnings,
      };
    }

    // Verify discipline belongs to Orchestrator
    if (discipline.parentVpId && discipline.parentVpId !== vpId) {
      warnings.push(
        `Discipline ${disciplineId} is not directly under Orchestrator ${vpId}`
      );
    }

    // Get agents for the discipline
    const agents = await registryManager.agents.listByDiscipline(disciplineId);

    // Include additional agents if specified
    const allAgents = [...agents];
    if (options.additionalAgents && options.additionalAgents.length > 0) {
      for (const agentId of options.additionalAgents) {
        const agent = await registryManager.agents.get(agentId);
        if (agent) {
          allAgents.push(agent);
        } else {
          warnings.push(`Additional agent not found: ${agentId}`);
        }
      }
    }

    // Generate CLAUDE.md content
    const claudeMdContent = generateClaudeMdContent(
      discipline.name,
      discipline.claudeMd.role,
      discipline.claudeMd.context,
      discipline.claudeMd.rules,
      discipline.claudeMd.objectives,
      discipline.claudeMd.constraints,
      options.taskDescription
    );

    // Generate claude_config.json
    const claudeConfigJson: Record<string, unknown> = {
      model: 'claude-sonnet-4-20250514',
      mcpServers: discipline.mcpServers.reduce(
        (acc, server) => {
          acc[server.name] = {
            command: server.command,
            args: server.args ?? [],
            env: server.env ?? {},
          };
          return acc;
        },
        {} as Record<string, unknown>
      ),
      hooks: discipline.hooks.map(hook => ({
        event: hook.event,
        command: hook.command,
        blocking: hook.blocking ?? false,
      })),
      ...options.mcpOverrides,
    };

    // Generate settings.json
    const settingsJson: Record<string, unknown> = {
      sessionId: generateSessionId(),
      vpId,
      disciplineId,
      taskDescription: options.taskDescription,
      createdAt: new Date().toISOString(),
      warmStart: !!options.warmStartContext,
    };

    // Generate agent definition paths
    const agentDefinitions = allAgents.map(
      agent => `.claude/agents/${agent.slug}.md`
    );

    // Build compiled session config
    const sessionConfig: CompiledSessionConfig = {
      claudeMdContent,
      claudeConfigJson,
      settingsJson,
      agentDefinitions,
    };

    // Calculate compilation time
    const compilationTimeMs = Date.now() - startTime;

    // Write files if requested and not dry-run
    const filesWritten: string[] = [];
    const worktreePath = options.worktreePath;

    if (options.writeFiles && !options.dryRun && worktreePath) {
      const fs = await import('node:fs/promises');
      const path = await import('node:path');

      // Ensure directories exist
      await fs.mkdir(path.join(worktreePath, '.claude/agents'), {
        recursive: true,
      });

      // Write CLAUDE.md
      const claudeMdPath = path.join(worktreePath, 'CLAUDE.md');
      await fs.writeFile(claudeMdPath, claudeMdContent, 'utf-8');
      filesWritten.push('CLAUDE.md');

      // Write claude_config.json
      const configPath = path.join(worktreePath, '.claude/claude_config.json');
      await fs.writeFile(
        configPath,
        JSON.stringify(claudeConfigJson, null, 2),
        'utf-8'
      );
      filesWritten.push('.claude/claude_config.json');

      // Write settings.json
      const settingsPath = path.join(worktreePath, '.claude/settings.json');
      await fs.writeFile(
        settingsPath,
        JSON.stringify(settingsJson, null, 2),
        'utf-8'
      );
      filesWritten.push('.claude/settings.json');

      // Write agent definitions
      for (const agent of allAgents) {
        const agentPath = path.join(
          worktreePath,
          '.claude/agents',
          `${agent.slug}.md`
        );
        const agentContent = `# ${agent.name}\n\n${agent.charter}\n`;
        await fs.writeFile(agentPath, agentContent, 'utf-8');
        filesWritten.push(`.claude/agents/${agent.slug}.md`);
      }
    } else if (options.dryRun) {
      warnings.push('Dry-run mode: Files were not written');
    }

    // Build session context
    const sessionContext: SessionContext = {
      id: settingsJson.sessionId as string,
      disciplineId,
      parentVpId: vpId,
      worktreePath: worktreePath ?? '',
      status: 'ready',
      compiledConfig: sessionConfig,
      memoryBank: {
        activeContextPath: '.memory/active-context.json',
        progressPath: '.memory/progress.json',
        productContextPath: '.memory/product-context.json',
        decisionLogPath: '.memory/decision-log.json',
      },
      activeAgentIds: allAgents.map(a => a.id),
      metadata: {
        taskDescription: options.taskDescription,
        compiledAt: new Date().toISOString(),
      },
    };

    return {
      success: true,
      sessionConfig,
      sessionContext,
      worktreePath,
      filesWritten,
      compilationTimeMs,
      warnings,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
      warnings,
      compilationTimeMs: Date.now() - startTime,
    };
  }
}

/**
 * CLI entry point for the compile command.
 *
 * Parses command-line arguments and invokes the compileCommand function.
 *
 * @param args - Command-line arguments
 *
 * @example
 * ```bash
 * # Basic compilation
 * wundr compile orchestrator-engineering disc-frontend --task "Implement login"
 *
 * # Compile and write files
 * wundr compile orchestrator-engineering disc-backend \
 *   --task "Build API" \
 *   --worktree ./worktrees/api \
 *   --write \
 *   --agents api-designer,security-reviewer
 *
 * # JSON output
 * wundr compile orchestrator-engineering disc-frontend \
 *   --task "Dashboard" \
 *   --format json
 * ```
 */
export async function runCompileCommand(args: string[]): Promise<void> {
  // Parse arguments
  const vpId = args[0];
  const disciplineId = args[1];

  if (!vpId || !disciplineId) {
    console.error('Error: Orchestrator ID and Discipline ID are required');
    console.error(
      'Usage: wundr compile <orchestrator-id> <discipline-id> --task <description> [options]'
    );
    process.exitCode = 1;
    return;
  }

  const options: CompileOptions = {
    taskDescription: '',
    outputFormat: 'text',
    writeFiles: false,
    dryRun: false,
  };

  // Parse flags
  for (let i = 2; i < args.length; i++) {
    const arg = args[i];
    const nextArg = args[i + 1];

    switch (arg) {
      case '--task':
      case '-t':
        options.taskDescription = nextArg ?? '';
        i++;
        break;
      case '--worktree':
      case '-w':
        options.worktreePath = nextArg;
        i++;
        break;
      case '--agents':
      case '-a':
        options.additionalAgents = (nextArg ?? '').split(',');
        i++;
        break;
      case '--warm-start':
        options.warmStartContext = nextArg;
        i++;
        break;
      case '--write':
        options.writeFiles = true;
        break;
      case '--repo':
        options.repoPath = nextArg;
        i++;
        break;
      case '--dry-run':
        options.dryRun = true;
        break;
      case '--format':
      case '-f':
        options.outputFormat = (nextArg ?? 'text') as 'text' | 'json';
        i++;
        break;
      case '--registry-path':
        options.registryPath = nextArg;
        i++;
        break;
    }
  }

  if (!options.taskDescription) {
    console.error('Error: Task description is required (--task)');
    process.exitCode = 1;
    return;
  }

  // Execute command
  const result = await compileCommand(vpId, disciplineId, options);

  // Output result
  if (options.outputFormat === 'json') {
    formatJsonOutput(result);
  } else {
    formatTextOutput(result);
  }

  if (!result.success) {
    process.exitCode = 1;
  }
}
