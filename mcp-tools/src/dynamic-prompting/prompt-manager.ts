/**
 * Dynamic Prompt Manager for Dynamic Prompting System
 *
 * Core class that orchestrates context detection, persona selection,
 * and prompt resolution with configurable merging strategies.
 *
 * @module mcp-tools/dynamic-prompting/prompt-manager
 */

import { ContextDetector } from './context-detector.js';
import { createPersonaLibrary } from './persona-library.js';

import type {
  DetectedContext,
  DynamicPromptConfig,
  DynamicPromptingArgs,
  DynamicPromptingResult,
  MergingStrategy,
  PersonaConfig,
  PersonaLibrary,
  ResolvedPrompt,
} from './types.js';

/**
 * Default configuration for the Dynamic Prompt Manager
 */
const DEFAULT_CONFIG: DynamicPromptConfig = {
  enableAutoDetection: true,
  defaultMergingStrategy: 'augment',
  confidenceThreshold: 0.3,
  maxLayeredPersonas: 3,
  fallbackPersonaId: 'software-engineer',
  allowConflicts: false,
};

/**
 * Dynamic Prompt Manager
 *
 * Orchestrates the dynamic prompting system by combining context detection,
 * persona selection, and prompt resolution.
 */
export class DynamicPromptManager {
  private config: DynamicPromptConfig;
  private library: PersonaLibrary;
  private detector: ContextDetector;

  /**
   * Create a new DynamicPromptManager instance
   *
   * @param config - Optional configuration overrides
   */
  constructor(config?: Partial<DynamicPromptConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.library = createPersonaLibrary(true);
    this.detector = new ContextDetector(this.config.customDetectionRules);

    // Add custom personas if provided
    if (this.config.customPersonas) {
      for (const persona of this.config.customPersonas) {
        this.library.add(persona);
      }
    }
  }

  /**
   * Execute a dynamic prompting operation
   *
   * @param args - Operation arguments
   * @returns Operation result
   */
  async execute(args: DynamicPromptingArgs): Promise<string> {
    try {
      let result: DynamicPromptingResult;

      switch (args.action) {
        case 'resolve':
          result = await this.handleResolve(args);
          break;
        case 'detect-context':
          result = await this.handleDetectContext(args);
          break;
        case 'list-personas':
          result = await this.handleListPersonas(args);
          break;
        case 'get-persona':
          result = await this.handleGetPersona(args);
          break;
        case 'add-persona':
          result = await this.handleAddPersona(args);
          break;
        case 'remove-persona':
          result = await this.handleRemovePersona(args);
          break;
        default:
          result = {
            success: false,
            action: args.action,
            message: `Unknown action: ${args.action}`,
            error: `Unsupported action: ${args.action}`,
          };
      }

      return JSON.stringify(result, null, 2);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      return JSON.stringify(
        {
          success: false,
          action: args.action,
          message: 'Operation failed',
          error: errorMessage,
        },
        null,
        2
      );
    }
  }

  /**
   * Resolve a system prompt based on context and configuration
   *
   * @param content - Content to analyze for context
   * @param filePaths - File paths for additional context signals
   * @param userHints - User-provided hints
   * @param personaIds - Explicit persona IDs to use
   * @param mergingStrategy - Strategy override
   * @returns Resolved prompt configuration
   */
  resolveSystemPrompt(
    content?: string,
    filePaths?: string[],
    userHints?: string[],
    personaIds?: string[],
    mergingStrategy?: MergingStrategy
  ): ResolvedPrompt {
    // Detect context if auto-detection is enabled
    const detectedContext = this.config.enableAutoDetection
      ? this.detector.detect(content, filePaths, userHints)
      : this.createDefaultContext();

    // Determine which personas to use
    const selectedPersonas = this.selectPersonas(detectedContext, personaIds);

    // Apply merging strategy
    const strategy = mergingStrategy || this.config.defaultMergingStrategy;
    const systemPrompt = this.mergePersonas(selectedPersonas, strategy);

    return {
      systemPrompt,
      activePersonas: selectedPersonas,
      mergingStrategy: strategy,
      detectedContext,
      isAutoGenerated: !personaIds || personaIds.length === 0,
      resolvedAt: new Date(),
      metadata: {
        configuredThreshold: this.config.confidenceThreshold,
        autoDetectionEnabled: this.config.enableAutoDetection,
      },
    };
  }

  /**
   * Generate a formatted persona library summary
   *
   * @param domain - Optional domain filter
   * @param taskType - Optional task type filter
   * @returns Formatted library summary
   */
  generatePersonaLibrary(domain?: string, taskType?: string): string {
    let personas = this.library.getAll();

    // Apply filters
    if (domain) {
      personas = personas.filter(p =>
        p.domains.includes(domain as PersonaConfig['domains'][number])
      );
    }

    if (taskType) {
      personas = personas.filter(p =>
        p.taskTypes.includes(taskType as PersonaConfig['taskTypes'][number])
      );
    }

    // Format output
    const lines: string[] = [
      '# Available Personas',
      '',
      `Total: ${personas.length} persona(s)`,
      '',
    ];

    for (const persona of personas) {
      lines.push(`## ${persona.name} (${persona.id})`);
      lines.push(`Priority: ${persona.priority}`);
      lines.push(`Description: ${persona.description}`);
      lines.push(`Domains: ${persona.domains.join(', ')}`);
      lines.push(`Task Types: ${persona.taskTypes.join(', ')}`);
      if (persona.tags) {
        lines.push(`Tags: ${persona.tags.join(', ')}`);
      }
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Get the persona library instance
   */
  getLibrary(): PersonaLibrary {
    return this.library;
  }

  /**
   * Get the context detector instance
   */
  getDetector(): ContextDetector {
    return this.detector;
  }

  /**
   * Update configuration
   *
   * @param config - Configuration updates
   */
  updateConfig(config: Partial<DynamicPromptConfig>): void {
    this.config = { ...this.config, ...config };

    // Update detector with new rules if provided
    if (config.customDetectionRules) {
      this.detector = new ContextDetector(config.customDetectionRules);
    }

    // Add new custom personas
    if (config.customPersonas) {
      for (const persona of config.customPersonas) {
        if (!this.library.exists(persona.id)) {
          this.library.add(persona);
        }
      }
    }
  }

  /**
   * Handle resolve action
   */
  private async handleResolve(
    args: DynamicPromptingArgs
  ): Promise<DynamicPromptingResult> {
    const resolvedPrompt = this.resolveSystemPrompt(
      args.content,
      args.filePaths,
      args.userHints,
      args.personaIds,
      args.mergingStrategy
    );

    return {
      success: true,
      action: 'resolve',
      message: `Resolved prompt using ${resolvedPrompt.activePersonas.length} persona(s)`,
      resolvedPrompt,
    };
  }

  /**
   * Handle detect-context action
   */
  private async handleDetectContext(
    args: DynamicPromptingArgs
  ): Promise<DynamicPromptingResult> {
    const detectedContext = this.detector.detect(
      args.content,
      args.filePaths,
      args.userHints
    );

    return {
      success: true,
      action: 'detect-context',
      message: `Detected domain: ${detectedContext.domain}, task: ${detectedContext.taskType}`,
      detectedContext,
    };
  }

  /**
   * Handle list-personas action
   */
  private async handleListPersonas(
    args: DynamicPromptingArgs
  ): Promise<DynamicPromptingResult> {
    let personas: PersonaConfig[];

    if (args.query) {
      personas = this.library.search(args.query);
    } else if (args.domain) {
      personas = this.library.getByDomain(args.domain);
    } else if (args.taskType) {
      personas = this.library.getByTaskType(args.taskType);
    } else {
      personas = this.library.getAll();
    }

    // Exclude configured exclusions
    if (this.config.excludedPersonas) {
      personas = personas.filter(
        p => !this.config.excludedPersonas!.includes(p.id)
      );
    }

    return {
      success: true,
      action: 'list-personas',
      message: `Found ${personas.length} persona(s)`,
      personas,
    };
  }

  /**
   * Handle get-persona action
   */
  private async handleGetPersona(
    args: DynamicPromptingArgs
  ): Promise<DynamicPromptingResult> {
    if (!args.personaId) {
      return {
        success: false,
        action: 'get-persona',
        message: 'Persona ID is required',
        error: 'Missing personaId parameter',
      };
    }

    const persona = this.library.getById(args.personaId);

    if (!persona) {
      return {
        success: false,
        action: 'get-persona',
        message: `Persona not found: ${args.personaId}`,
        error: `No persona with ID: ${args.personaId}`,
      };
    }

    return {
      success: true,
      action: 'get-persona',
      message: `Found persona: ${persona.name}`,
      persona,
    };
  }

  /**
   * Handle add-persona action
   */
  private async handleAddPersona(
    args: DynamicPromptingArgs
  ): Promise<DynamicPromptingResult> {
    if (!args.persona) {
      return {
        success: false,
        action: 'add-persona',
        message: 'Persona configuration is required',
        error: 'Missing persona parameter',
      };
    }

    try {
      this.library.add(args.persona);
      return {
        success: true,
        action: 'add-persona',
        message: `Added persona: ${args.persona.name}`,
        persona: args.persona,
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      return {
        success: false,
        action: 'add-persona',
        message: 'Failed to add persona',
        error: errorMessage,
      };
    }
  }

  /**
   * Handle remove-persona action
   */
  private async handleRemovePersona(
    args: DynamicPromptingArgs
  ): Promise<DynamicPromptingResult> {
    if (!args.personaId) {
      return {
        success: false,
        action: 'remove-persona',
        message: 'Persona ID is required',
        error: 'Missing personaId parameter',
      };
    }

    try {
      const removed = this.library.remove(args.personaId);

      if (!removed) {
        return {
          success: false,
          action: 'remove-persona',
          message: `Persona not found: ${args.personaId}`,
          error: `No persona with ID: ${args.personaId}`,
        };
      }

      return {
        success: true,
        action: 'remove-persona',
        message: `Removed persona: ${args.personaId}`,
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      return {
        success: false,
        action: 'remove-persona',
        message: 'Failed to remove persona',
        error: errorMessage,
      };
    }
  }

  /**
   * Select personas based on context and explicit IDs
   */
  private selectPersonas(
    context: DetectedContext,
    explicitIds?: string[]
  ): PersonaConfig[] {
    const selected: PersonaConfig[] = [];
    const selectedIds = new Set<string>();

    // First, add explicitly requested personas
    if (explicitIds && explicitIds.length > 0) {
      for (const id of explicitIds) {
        const persona = this.library.getById(id);
        if (persona && !this.isExcluded(id)) {
          selected.push(persona);
          selectedIds.add(id);
        }
      }
    }

    // If we have enough explicit personas, return them
    if (selected.length >= this.config.maxLayeredPersonas) {
      return selected.slice(0, this.config.maxLayeredPersonas);
    }

    // Add context-recommended personas if confidence is high enough
    if (
      context.domainConfidence >= this.config.confidenceThreshold ||
      context.taskConfidence >= this.config.confidenceThreshold
    ) {
      for (const personaId of context.recommendedPersonas) {
        if (
          !selectedIds.has(personaId) &&
          !this.isExcluded(personaId) &&
          selected.length < this.config.maxLayeredPersonas
        ) {
          const persona = this.library.getById(personaId);
          if (persona && this.isCompatible(persona, selected)) {
            selected.push(persona);
            selectedIds.add(personaId);
          }
        }
      }
    }

    // Add fallback persona if no personas selected
    if (selected.length === 0 && this.config.fallbackPersonaId) {
      const fallback = this.library.getById(this.config.fallbackPersonaId);
      if (fallback) {
        selected.push(fallback);
      }
    }

    return selected;
  }

  /**
   * Check if a persona is excluded
   */
  private isExcluded(personaId: string): boolean {
    return this.config.excludedPersonas?.includes(personaId) ?? false;
  }

  /**
   * Check if a persona is compatible with already selected personas
   */
  private isCompatible(
    persona: PersonaConfig,
    selected: PersonaConfig[]
  ): boolean {
    if (this.config.allowConflicts) {
      return true;
    }

    for (const existing of selected) {
      // Check if the new persona conflicts with existing
      if (existing.conflictsWith?.includes(persona.id)) {
        return false;
      }

      // Check if existing persona conflicts with new
      if (persona.conflictsWith?.includes(existing.id)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Merge multiple personas into a single system prompt
   */
  private mergePersonas(
    personas: PersonaConfig[],
    strategy: MergingStrategy
  ): string {
    if (personas.length === 0) {
      return 'You are a helpful assistant.';
    }

    if (personas.length === 1) {
      return personas[0].systemPrompt;
    }

    switch (strategy) {
      case 'replace':
        // Use only the highest priority persona
        return personas[0].systemPrompt;

      case 'augment':
        return this.augmentPersonas(personas);

      case 'layer':
        return this.layerPersonas(personas);

      default:
        return personas[0].systemPrompt;
    }
  }

  /**
   * Augment personas by combining their prompts
   */
  private augmentPersonas(personas: PersonaConfig[]): string {
    const sections: string[] = [];

    sections.push('# Combined Expert Persona');
    sections.push('');
    sections.push(
      'You are an AI assistant with expertise in multiple domains:'
    );
    sections.push('');

    for (const persona of personas) {
      sections.push(`## ${persona.name}`);
      sections.push(persona.systemPrompt);
      sections.push('');
    }

    sections.push('---');
    sections.push('');
    sections.push(
      'Integrate all the above expertise and guidelines when responding. Prioritize based on the specific task at hand.'
    );

    return sections.join('\n');
  }

  /**
   * Layer personas with priority ordering
   */
  private layerPersonas(personas: PersonaConfig[]): string {
    const sections: string[] = [];

    sections.push('# Layered Expert Persona');
    sections.push('');
    sections.push(
      'You operate with multiple layers of expertise, prioritized as follows:'
    );
    sections.push('');

    const priorityOrder = ['critical', 'high', 'medium', 'low'];

    for (const priority of priorityOrder) {
      const priorityPersonas = personas.filter(p => p.priority === priority);

      if (priorityPersonas.length > 0) {
        sections.push(`## Priority: ${priority.toUpperCase()}`);
        sections.push('');

        for (const persona of priorityPersonas) {
          sections.push(`### ${persona.name}`);
          sections.push(persona.systemPrompt);
          sections.push('');
        }
      }
    }

    sections.push('---');
    sections.push('');
    sections.push(
      'Apply guidelines from higher priority personas first, then layer in additional context from lower priority personas as needed.'
    );

    return sections.join('\n');
  }

  /**
   * Create a default context when auto-detection is disabled
   */
  private createDefaultContext(): DetectedContext {
    return {
      domain: 'general',
      taskType: 'general',
      domainConfidence: 0,
      taskConfidence: 0,
      recommendedPersonas: this.config.fallbackPersonaId
        ? [this.config.fallbackPersonaId]
        : [],
      signals: {},
    };
  }
}

/**
 * Create a new DynamicPromptManager instance
 *
 * @param config - Optional configuration
 * @returns A new DynamicPromptManager instance
 */
export function createDynamicPromptManager(
  config?: Partial<DynamicPromptConfig>
): DynamicPromptManager {
  return new DynamicPromptManager(config);
}
